{"version":3,"file":"main.js","sources":["../../../../../sample/worker/main.ts"],"sourcesContent":["const canvas = document.querySelector('canvas') as HTMLCanvasElement;\n\n// The web worker is created by passing a path to the worker's source file, which will then be\n// executed on a separate thread.\nconst worker = new Worker(new URL('./worker.js', import.meta.url));\n\n// The primary way to communicate with the worker is to send and receive messages.\nworker.addEventListener('message', (ev) => {\n  // The format of the message can be whatever you'd like, but it's helpful to decide on a\n  // consistent convention so that you can tell the message types apart as your apps grow in\n  // complexity. Here we establish a convention that all messages to and from the worker will\n  // have a `type` field that we can use to determine the content of the message.\n  switch (ev.data.type) {\n    default: {\n      console.error(`Unknown Message Type: ${ev.data.type}`);\n    }\n  }\n});\n\ntry {\n  // In order for the worker to display anything on the page, an OffscreenCanvas must be used.\n  // Here we can create one from our normal canvas by calling transferControlToOffscreen().\n  // Anything drawn to the OffscreenCanvas that call returns will automatically be displayed on\n  // the source canvas on the page.\n  const offscreenCanvas = canvas.transferControlToOffscreen();\n  const devicePixelRatio = window.devicePixelRatio;\n  offscreenCanvas.width = canvas.clientWidth * devicePixelRatio;\n  offscreenCanvas.height = canvas.clientHeight * devicePixelRatio;\n\n  // Send a message to the worker telling it to initialize WebGPU with the OffscreenCanvas. The\n  // array passed as the second argument here indicates that the OffscreenCanvas is to be\n  // transferred to the worker, meaning this main thread will lose access to it and it will be\n  // fully owned by the worker.\n  worker.postMessage({ type: 'init', offscreenCanvas }, [offscreenCanvas]);\n} catch (err) {\n  // TODO: This catch is added here because React will call init twice with the same canvas, and\n  // the second time will fail the transferControlToOffscreen() because it's already been\n  // transferred. I'd love to know how to get around that.\n  console.warn(err.message);\n  worker.terminate();\n}\n"],"names":[],"mappings":"AAAA,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAsB,CAAC;AAErE;AACA;AACA,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,GAAG,CAAC,aAAa,EAAE,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;AAEnE;AACA,MAAM,CAAC,gBAAgB,CAAC,SAAS,EAAE,CAAC,EAAE,KAAI;;;;;AAKxC,IAAA,QAAQ,EAAE,CAAC,IAAI,CAAC,IAAI;QAClB,SAAS;YACP,OAAO,CAAC,KAAK,CAAC,CAAyB,sBAAA,EAAA,EAAE,CAAC,IAAI,CAAC,IAAI,CAAE,CAAA,CAAC,CAAC;SACxD;KACF;AACH,CAAC,CAAC,CAAC;AAEH,IAAI;;;;;AAKF,IAAA,MAAM,eAAe,GAAG,MAAM,CAAC,0BAA0B,EAAE,CAAC;AAC5D,IAAA,MAAM,gBAAgB,GAAG,MAAM,CAAC,gBAAgB,CAAC;IACjD,eAAe,CAAC,KAAK,GAAG,MAAM,CAAC,WAAW,GAAG,gBAAgB,CAAC;IAC9D,eAAe,CAAC,MAAM,GAAG,MAAM,CAAC,YAAY,GAAG,gBAAgB,CAAC;;;;;AAMhE,IAAA,MAAM,CAAC,WAAW,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,eAAe,EAAE,EAAE,CAAC,eAAe,CAAC,CAAC,CAAC;AAC3E,CAAC;AAAC,OAAO,GAAG,EAAE;;;;AAIZ,IAAA,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IAC1B,MAAM,CAAC,SAAS,EAAE,CAAC;AACrB"}