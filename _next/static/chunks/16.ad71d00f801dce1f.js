(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[16],{5671:function(e,n,t){"use strict";t.d(n,{Tl:function(){return c},hu:function(){return p}});var r=t(5893),o=t(9008),a=t.n(o),i=t(1163),s=t(7294),l=t(9147),u=t.n(l);t(7319);let d=e=>{let n=(0,s.useRef)(null),o=(0,s.useMemo)(()=>e.sources.map(e=>{let{name:n,contents:o}=e;return{name:n,...function(e){let n;let o=null;{o=document.createElement("div");let a=t(4631);n=a(o,{lineNumbers:!0,lineWrapping:!0,theme:"monokai",readOnly:!0})}return{Container:function(t){return(0,r.jsx)("div",{...t,children:(0,r.jsx)("div",{ref(t){o&&t&&(t.appendChild(o),n.setOption("value",e))}})})}}}(o)}}),e.sources),l=(0,s.useRef)(null),d=(0,s.useMemo)(()=>{if(e.gui){let n=t(4376),r=new n.GUI({autoPlace:!1});return r.domElement.style.position="relative",r.domElement.style.zIndex="1000",r}},[]),c=(0,s.useRef)(null),p=(0,s.useMemo)(()=>{if(e.stats){let n=t(2792);return new n}},[]),m=(0,i.useRouter)(),f=m.asPath.match(/#([a-zA-Z0-9\.\/]+)/),[g,h]=(0,s.useState)(null),[S,E]=(0,s.useState)(null);return(0,s.useEffect)(()=>{if(f?E(f[1]):E(o[0].name),d&&l.current)for(l.current.appendChild(d.domElement);d.__controllers.length>0;)d.__controllers[0].remove();p&&c.current&&(p.dom.style.position="absolute",p.showPanel(1),c.current.appendChild(p.dom));let t={active:!0},r=()=>{t.active=!1};try{let a=n.current;if(!a)throw Error("The canvas is not available");let i=e.init({canvas:a,pageState:t,gui:d,stats:p});i instanceof Promise&&i.catch(e=>{console.error(e),h(e)})}catch(s){console.error(s),h(s)}return r},[]),(0,r.jsxs)("main",{children:[(0,r.jsxs)(a(),{children:[(0,r.jsx)("style",{dangerouslySetInnerHTML:{__html:"\n            .CodeMirror {\n              height: auto !important;\n              margin: 1em 0;\n            }\n\n            .CodeMirror-scroll {\n              height: auto !important;\n              overflow: visible !important;\n            }\n          "}}),(0,r.jsx)("title",{children:"".concat(e.name," - WebGPU Samples")}),(0,r.jsx)("meta",{name:"description",content:e.description}),(0,r.jsx)("meta",{httpEquiv:"origin-trial",content:e.originTrial})]}),(0,r.jsxs)("div",{children:[(0,r.jsx)("h1",{children:e.name}),(0,r.jsx)("a",{target:"_blank",rel:"noreferrer",href:"https://github.com/".concat("webgpu/webgpu-samples","/tree/main/").concat(e.filename),children:"See it on Github!"}),(0,r.jsx)("p",{children:e.description}),g?(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("p",{children:"Something went wrong. Do your browser and device support WebGPU?"}),(0,r.jsx)("p",{children:"".concat(g)})]}):null]}),(0,r.jsxs)("div",{className:u().canvasContainer,children:[(0,r.jsx)("div",{style:{position:"absolute",left:10},ref:c}),(0,r.jsx)("div",{style:{position:"absolute",right:10},ref:l}),(0,r.jsx)("canvas",{ref:n})]}),(0,r.jsxs)("div",{children:[(0,r.jsx)("nav",{className:u().sourceFileNav,children:(0,r.jsx)("ul",{children:o.map((e,n)=>(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"#".concat(e.name),"data-active":S==e.name,onClick(){E(e.name)},children:e.name})},n))})}),o.map((e,n)=>(0,r.jsx)(e.Container,{className:u().sourceFileContainer,"data-active":S==e.name},n))]})]})},c=e=>(0,r.jsx)(d,{...e});function p(e,n){if(!e)throw Error(n)}},5016:function(e,n,t){"use strict";let r;t.r(n),t.d(n,{default:function(){return E}});var o,a,i=t(5671),s=t(134);let l=(e,n,t,r,o,a,i)=>{let s=[];for(let l=0;l<e.length;l++)s.push({binding:e[l],visibility:n[l%n.length],[t[l]]:r[l]});let u=i.createBindGroupLayout({label:"".concat(a,".bindGroupLayout"),entries:s}),d=[];for(let c=0;c<o.length;c++){let p=[];for(let m=0;m<o[0].length;m++)p.push({binding:m,resource:o[c][m]});let f=i.createBindGroup({label:"".concat(a,".bindGroup").concat(c),layout:u,entries:p});d.push(f)}return{bindGroups:d,bindGroupLayout:u}},u=async e=>{let n=async n=>{let{canvas:t,pageState:r,gui:o,stats:a}=n,i=await navigator.gpu.requestAdapter(),s=await i.requestDevice();if(!r.active)return;let l=t.getContext("webgpu"),u=window.devicePixelRatio;t.width=t.clientWidth*u,t.height=t.clientHeight*u;let d=navigator.gpu.getPreferredCanvasFormat();l.configure({device:s,format:d,alphaMode:"premultiplied"}),e({canvas:t,pageState:r,gui:o,device:s,context:l,presentationFormat:d,stats:a})};return n};class d{executeRun(e,n,t,r){let o=e.beginRenderPass(n);o.setPipeline(t);for(let a=0;a<r.length;a++)o.setBindGroup(a,r[a]);o.draw(6,1,0,0),o.end()}setUniformArguments(e,n,t,r){for(let o=0;o<r.length;o++)e.queue.writeBuffer(n,4*o,new Float32Array([t[r[o]]]))}create2DRenderPipeline(e,n,t,r,o){return e.createRenderPipeline({label:"".concat(n,".pipeline"),layout:e.createPipelineLayout({bindGroupLayouts:t}),vertex:{module:e.createShaderModule({code:s.Z}),entryPoint:"vert_main"},fragment:{module:e.createShaderModule({code:r}),entryPoint:"frag_main",targets:[{format:o}]},primitive:{topology:"triangle-list",cullMode:"none"}})}}var c="struct ComputeUniforms {\n  width: f32,\n  height: f32,\n  algo: u32,\n  blockHeight: u32,\n}\n\nstruct FragmentUniforms {\n  // boolean, either 0 or 1\n  highlight: u32,\n}\n\nstruct VertexOutput {\n  @builtin(position) Position: vec4<f32>,\n  @location(0) fragUV: vec2<f32>\n}\n\n// Uniforms from compute shader\n@group(0) @binding(0) var<storage, read> data: array<u32>;\n@group(0) @binding(2) var<uniform> uniforms: ComputeUniforms;\n// Fragment shader uniforms\n@group(1) @binding(0) var<uniform> fragment_uniforms: FragmentUniforms;\n\n@fragment\nfn frag_main(input: VertexOutput) -> @location(0) vec4<f32> {\n  var uv: vec2<f32> = vec2<f32>(\n    input.fragUV.x * uniforms.width,\n    input.fragUV.y * uniforms.height\n  );\n\n  var pixel: vec2<u32> = vec2<u32>(\n    u32(floor(uv.x)),\n    u32(floor(uv.y)),\n  );\n  \n  var elementIndex = u32(uniforms.width) * pixel.y + pixel.x;\n  var colorChanger = data[elementIndex];\n\n  var subtracter = f32(colorChanger) / (uniforms.width * uniforms.height);\n\n  if (fragment_uniforms.highlight == 1) {\n    return select(\n      //If element is above halfHeight, highlight green\n      vec4<f32>(vec3<f32>(0.0, 1.0 - subtracter, 0.0).rgb, 1.0),\n      //If element is below halfheight, highlight red\n      vec4<f32>(vec3<f32>(1.0 - subtracter, 0.0, 0.0).rgb, 1.0),\n      elementIndex % uniforms.blockHeight < uniforms.blockHeight / 2\n    );\n  }\n\n  var color: vec3<f32> = vec3f(\n    1.0 - subtracter\n  );\n\n  return vec4<f32>(color.rgb, 1.0);\n}\n";class p extends d{startRun(e,n){this.setArguments(n),super.executeRun(e,this.renderPassDescriptor,this.pipeline,[this.computeBGDescript.bindGroups[0],this.currentBindGroup])}constructor(e,n,t,r,o){super(),this.renderPassDescriptor=t,this.computeBGDescript=r;let a=e.createBuffer({size:Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),i=l([0],[GPUShaderStage.FRAGMENT],["buffer"],[{type:"uniform"}],[[{buffer:a}]],o,e);this.currentBindGroup=i.bindGroups[0],this.pipeline=super.create2DRenderPipeline(e,o,[this.computeBGDescript.bindGroupLayout,i.bindGroupLayout],c,n),this.setArguments=n=>{e.queue.writeBuffer(a,0,new Uint32Array([n.highlight]))}}}p.sourceInfo={name:"src/sample/bitonicSort/bitonicDisplay.ts".substring(23),contents:"import {\n  BindGroupCluster,\n  Base2DRendererClass,\n  createBindGroupCluster,\n} from './utils';\n\nimport bitonicDisplay from './bitonicDisplay.frag.wgsl';\n\ninterface BitonicDisplayRenderArgs {\n  highlight: number;\n}\n\nexport default class BitonicDisplayRenderer extends Base2DRendererClass {\n  static sourceInfo = {\n    name: __filename.substring(__dirname.length + 1),\n    contents: __SOURCE__,\n  };\n\n  switchBindGroup: (name: string) => void;\n  setArguments: (args: BitonicDisplayRenderArgs) => void;\n  computeBGDescript: BindGroupCluster;\n\n  constructor(\n    device: GPUDevice,\n    presentationFormat: GPUTextureFormat,\n    renderPassDescriptor: GPURenderPassDescriptor,\n    computeBGDescript: BindGroupCluster,\n    label: string\n  ) {\n    super();\n    this.renderPassDescriptor = renderPassDescriptor;\n    this.computeBGDescript = computeBGDescript;\n\n    const uniformBuffer = device.createBuffer({\n      size: Uint32Array.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n\n    const bgCluster = createBindGroupCluster(\n      [0],\n      [GPUShaderStage.FRAGMENT],\n      ['buffer'],\n      [{ type: 'uniform' }],\n      [[{ buffer: uniformBuffer }]],\n      label,\n      device\n    );\n\n    this.currentBindGroup = bgCluster.bindGroups[0];\n\n    this.pipeline = super.create2DRenderPipeline(\n      device,\n      label,\n      [this.computeBGDescript.bindGroupLayout, bgCluster.bindGroupLayout],\n      bitonicDisplay,\n      presentationFormat\n    );\n\n    this.setArguments = (args: BitonicDisplayRenderArgs) => {\n      device.queue.writeBuffer(\n        uniformBuffer,\n        0,\n        new Uint32Array([args.highlight])\n      );\n    };\n  }\n\n  startRun(commandEncoder: GPUCommandEncoder, args: BitonicDisplayRenderArgs) {\n    this.setArguments(args);\n    super.executeRun(commandEncoder, this.renderPassDescriptor, this.pipeline, [\n      this.computeBGDescript.bindGroups[0],\n      this.currentBindGroup,\n    ]);\n  }\n}\n"};let m=e=>((e%2!=0||e>256)&&(e=256),"\n\nstruct Uniforms {\n  width: f32,\n  height: f32,\n  algo: u32,\n  blockHeight: u32,\n}\n\n// Create local workgroup data that can contain all elements\nvar<workgroup> local_data: array<u32, ".concat(2*e,">;\n\n// Define groups (functions refer to this data)\n@group(0) @binding(0) var<storage, read> input_data: array<u32>;\n@group(0) @binding(1) var<storage, read_write> output_data: array<u32>;\n@group(0) @binding(2) var<uniform> uniforms: Uniforms;\n@group(0) @binding(3) var<storage, read_write> counter: atomic<u32>;\n\n// Compare and swap values in local_data\nfn local_compare_and_swap(idx_before: u32, idx_after: u32) {\n  //idx_before should always be < idx_after\n  if (local_data[idx_after] < local_data[idx_before]) {\n    atomicAdd(&counter, 1);\n    var temp: u32 = local_data[idx_before];\n    local_data[idx_before] = local_data[idx_after];\n    local_data[idx_after] = temp;\n  }\n  return;\n}\n\n// thread_id goes from 0 to threadsPerWorkgroup\nfn get_flip_indices(thread_id: u32, block_height: u32) -> vec2<u32> {\n  // Caculate index offset (i.e move indices into correct block)\n  let block_offset: u32 = ((2 * thread_id) / block_height) * block_height;\n  let half_height = block_height / 2;\n  // Calculate index spacing\n  var idx: vec2<u32> = vec2<u32>(\n    thread_id % half_height, block_height - (thread_id % half_height) - 1,\n  );\n  idx.x += block_offset;\n  idx.y += block_offset;\n  return idx;\n}\n\nfn get_disperse_indices(thread_id: u32, block_height: u32) -> vec2<u32> {\n  var block_offset: u32 = ((2 * thread_id) / block_height) * block_height;\n  let half_height = block_height / 2;\n	var idx: vec2<u32> = vec2<u32>(\n    thread_id % half_height, (thread_id % half_height) + half_height\n  );\n  idx.x += block_offset;\n  idx.y += block_offset;\n  return idx;\n}\n\nfn global_compare_and_swap(idx_before: u32, idx_after: u32) {\n  if (input_data[idx_after] < input_data[idx_before]) {\n    output_data[idx_before] = input_data[idx_after];\n    output_data[idx_after] = input_data[idx_before];\n  } \n}\n\n// Constants/enum\nconst ALGO_NONE = 0;\nconst ALGO_LOCAL_FLIP = 1;\nconst ALGO_LOCAL_DISPERSE = 2;\nconst ALGO_GLOBAL_FLIP = 3;\n\n// Our compute shader will execute specified # of threads or elements / 2 threads\n@compute @workgroup_size(").concat(e,", 1, 1)\nfn computeMain(\n  @builtin(global_invocation_id) global_id: vec3<u32>,\n  @builtin(local_invocation_id) local_id: vec3<u32>,\n  @builtin(workgroup_id) workgroup_id: vec3<u32>,\n) {\n\n  let offset = ").concat(e," * 2 * workgroup_id.x;\n  // If we will perform a local swap, then populate the local data\n  if (uniforms.algo <= 2) {\n    // Assign range of input_data to local_data.\n    // Range cannot exceed maxWorkgroupsX * 2\n    // Each thread will populate the workgroup data... (1 thread for every 2 elements)\n    local_data[local_id.x * 2] = input_data[offset + local_id.x * 2];\n    local_data[local_id.x * 2 + 1] = input_data[offset + local_id.x * 2 + 1];\n  }\n\n  //...and wait for each other to finish their own bit of data population.\n  workgroupBarrier();\n\n  switch uniforms.algo {\n    case 1: { // Local Flip\n      let idx = get_flip_indices(local_id.x, uniforms.blockHeight);\n      local_compare_and_swap(idx.x, idx.y);\n    } \n    case 2: { // Local Disperse\n      let idx = get_disperse_indices(local_id.x, uniforms.blockHeight);\n      local_compare_and_swap(idx.x, idx.y);\n    } \n    case 3: { // Global Flip\n      let idx = get_flip_indices(global_id.x, uniforms.blockHeight);\n      global_compare_and_swap(idx.x, idx.y);\n    }\n    case 4: { \n      let idx = get_disperse_indices(global_id.x, uniforms.blockHeight);\n      global_compare_and_swap(idx.x, idx.y);\n    }\n    default: { \n      \n    }\n  }\n\n  // Ensure that all threads have swapped their own regions of data\n  workgroupBarrier();\n\n  if (uniforms.algo <= ALGO_LOCAL_DISPERSE) {\n    //Repopulate global data with local data\n    output_data[offset + local_id.x * 2] = local_data[local_id.x * 2];\n    output_data[offset + local_id.x * 2 + 1] = local_data[local_id.x * 2 + 1];\n  }\n\n}"));var f="@group(0) @binding(3) var<storage, read_write> counter: atomic<u32>;\n\n@compute @workgroup_size(1, 1, 1)\nfn atomicToZero() {\n  let counterValue = atomicLoad(&counter);\n  atomicSub(&counter, counterValue);\n}",g="src/sample/bitonicSort/main.ts";(o=a||(a={}))[o.NONE=0]="NONE",o[o.FLIP_LOCAL=1]="FLIP_LOCAL",o[o.DISPERSE_LOCAL=2]="DISPERSE_LOCAL",o[o.FLIP_GLOBAL=3]="FLIP_GLOBAL",o[o.DISPERSE_GLOBAL=4]="DISPERSE_GLOBAL";let h=e=>{let n=Math.log2(e);return n*(n+1)/2};u(async e=>{let{pageState:n,device:t,gui:r,presentationFormat:o,context:i,canvas:s}=e,u=t.limits.maxComputeWorkgroupSizeX,d=[],c=32*u;for(let g=c;g>=4;g/=2)d.push(g);let S=Math.sqrt(c)%2==0?Math.floor(Math.sqrt(c)):Math.floor(Math.sqrt(c/2)),E={"Total Elements":c,"Grid Width":S,"Grid Height":c/S,"Total Threads":u,"Hovered Cell":0,"Swapped Cell":1,"Step Index":0,"Total Steps":h(c),"Prev Step":"NONE","Next Step":"FLIP_LOCAL","Prev Swap Span":0,"Next Swap Span":2,"Total Workgroups":c/(2*u),"Total Swaps":0,executeStep:!1,"Display Mode":"Elements","Randomize Values"(){},"Execute Sort Step"(){},"Log Elements"(){},"Complete Sort"(){},"Sort Speed":50},v=new Uint32Array(Array.from({length:E["Total Elements"]},(e,n)=>n)),x=Float32Array.BYTES_PER_ELEMENT*d[0],_=t.createBuffer({size:x,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),b=t.createBuffer({size:x,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),C=t.createBuffer({size:x,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),y=t.createBuffer({size:Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),P=t.createBuffer({size:Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),w=t.createBuffer({size:4*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),B=l([0,1,2,3],[GPUShaderStage.COMPUTE|GPUShaderStage.FRAGMENT,GPUShaderStage.COMPUTE,GPUShaderStage.COMPUTE|GPUShaderStage.FRAGMENT,GPUShaderStage.COMPUTE],["buffer","buffer","buffer","buffer"],[{type:"read-only-storage"},{type:"storage"},{type:"uniform"},{type:"storage"}],[[{buffer:_},{buffer:b},{buffer:w},{buffer:y}]],"BitonicSort",t),T=t.createComputePipeline({layout:t.createPipelineLayout({bindGroupLayouts:[B.bindGroupLayout]}),compute:{module:t.createShaderModule({code:m(E["Total Threads"])}),entryPoint:"computeMain"}}),G=t.createComputePipeline({layout:t.createPipelineLayout({bindGroupLayouts:[B.bindGroupLayout]}),compute:{module:t.createShaderModule({code:f}),entryPoint:"atomicToZero"}}),L={colorAttachments:[{view:void 0,clearValue:{r:.1,g:.4,b:.5,a:1},loadOp:"clear",storeOp:"store"}]},I=new p(t,o,L,B,"BitonicDisplay"),U=()=>{F.setValue(Math.min(E["Total Elements"]/2,u));let e=(E["Total Elements"]-1)/(2*u);H.setValue(Math.ceil(e)),X.setValue(0),Q.setValue(h(E["Total Elements"]));let n=Math.sqrt(E["Total Elements"])%2==0?Math.floor(Math.sqrt(E["Total Elements"])):Math.floor(Math.sqrt(E["Total Elements"]/2)),r=E["Total Elements"]/n;z.setValue(n),Y.setValue(r),J.setValue("NONE"),K.setValue("FLIP_LOCAL"),ee.setValue(0),en.setValue(2);let o=t.createCommandEncoder(),a=o.beginComputePass();a.setPipeline(G),a.setBindGroup(0,B.bindGroups[0]),a.dispatchWorkgroups(1),a.end(),t.queue.submit([o.finish()]),$.setValue(0),eo=2},A=()=>{let e=v.length;for(;0!==e;){let n=Math.floor(Math.random()*e);e-=1,[v[e],v[n]]=[v[n],v[e]]}},R=()=>{v=new Uint32Array(Array.from({length:E["Total Elements"]},(e,n)=>n)),U(),T=t.createComputePipeline({layout:t.createPipelineLayout({bindGroupLayouts:[B.bindGroupLayout]}),compute:{module:t.createShaderModule({code:m(E["Total Elements"]/2)}),entryPoint:"computeMain"}}),A(),eo=2};A();let M=()=>{let e;switch(E["Next Step"]){case"FLIP_LOCAL":case"FLIP_GLOBAL":{let n=E["Next Swap Span"],t=Math.floor(E["Hovered Cell"]/n)+1,r=E["Hovered Cell"]%n;e=n*t-r-1,j.setValue(e)}break;case"DISPERSE_LOCAL":{let o=E["Next Swap Span"],a=o/2;e=E["Hovered Cell"]%o<a?E["Hovered Cell"]+a:E["Hovered Cell"]-a,j.setValue(e)}break;case"NONE":e=E["Hovered Cell"],j.setValue(e);default:e=E["Hovered Cell"],j.setValue(e)}},O=null,k=()=>{null!==O&&(clearInterval(O),O=null)},D=()=>{let e=E["Sort Speed"];O=setInterval(()=>{"NONE"===E["Next Step"]&&(clearInterval(O),O=null),E["Sort Speed"]!==e&&(clearInterval(O),O=null,D()),E.executeStep=!0,M()},E["Sort Speed"])},N=r.addFolder("Compute Resources");N.add(E,"Total Elements",d).onChange(()=>{k(),R()});let F=N.add(E,"Total Threads"),H=N.add(E,"Total Workgroups");N.open();let V=r.addFolder("Sort Controls");V.add(E,"Sort Speed",50,1e3).step(50),V.add(E,"Execute Sort Step").onChange(()=>{k(),E.executeStep=!0}),V.add(E,"Randomize Values").onChange(()=>{k(),A(),U()}),V.add(E,"Log Elements").onChange(()=>console.log(v)),V.add(E,"Complete Sort").onChange(D),V.open();let W=r.addFolder("Grid Information");W.add(E,"Display Mode",["Elements","Swap Highlight"]);let z=W.add(E,"Grid Width"),Y=W.add(E,"Grid Height"),q=W.add(E,"Hovered Cell").onChange(M),j=W.add(E,"Swapped Cell"),Z=r.addFolder("Execution Information"),X=Z.add(E,"Step Index"),Q=Z.add(E,"Total Steps"),J=Z.add(E,"Prev Step"),K=Z.add(E,"Next Step"),$=Z.add(E,"Total Swaps"),ee=Z.add(E,"Prev Swap Span"),en=Z.add(E,"Next Swap Span"),et=document.getElementsByClassName("cr function");for(let er=0;er<et.length;er++)et[er].children[0].style.display="flex",et[er].children[0].style.justifyContent="center",et[er].children[0].children[1].style.position="absolute";s.addEventListener("mousemove",e=>{let n=s.getBoundingClientRect().width,t=s.getBoundingClientRect().height,r=[n/E["Grid Width"],t/E["Grid Height"]],o=Math.floor(e.offsetX/r[0]),a=E["Grid Height"]-1-Math.floor(e.offsetY/r[1]);q.setValue(a*E["Grid Width"]+o),E["Hovered Cell"]=a*E["Grid Width"]+o}),H.domElement.style.pointerEvents="none",q.domElement.style.pointerEvents="none",j.domElement.style.pointerEvents="none",X.domElement.style.pointerEvents="none",Q.domElement.style.pointerEvents="none",J.domElement.style.pointerEvents="none",ee.domElement.style.pointerEvents="none",K.domElement.style.pointerEvents="none",en.domElement.style.pointerEvents="none",F.domElement.style.pointerEvents="none",z.domElement.style.pointerEvents="none",Y.domElement.style.pointerEvents="none",$.domElement.style.pointerEvents="none";let eo=2;async function ea(){if(!n.active)return;t.queue.writeBuffer(_,0,v.buffer,v.byteOffset,v.byteLength);let e=new Float32Array([E["Grid Width"],E["Grid Height"]]),r=new Uint32Array([a[E["Next Step"]],E["Next Swap Span"]]);t.queue.writeBuffer(w,0,e.buffer,e.byteOffset,e.byteLength),t.queue.writeBuffer(w,8,r),L.colorAttachments[0].view=i.getCurrentTexture().createView();let o=t.createCommandEncoder();if(I.startRun(o,{highlight:"Elements"===E["Display Mode"]?0:1}),E.executeStep&&eo!==2*E["Total Elements"]){let s=o.beginComputePass();s.setPipeline(T),s.setBindGroup(0,B.bindGroups[0]),s.dispatchWorkgroups(E["Total Workgroups"]),s.end(),X.setValue(E["Step Index"]+1),J.setValue(E["Next Step"]),ee.setValue(E["Next Swap Span"]),en.setValue(E["Next Swap Span"]/2),1===E["Next Swap Span"]?(eo*=2)==2*E["Total Elements"]?(K.setValue("NONE"),en.setValue(0)):eo>2*E["Total Threads"]?(K.setValue("FLIP_GLOBAL"),en.setValue(eo)):(K.setValue("FLIP_LOCAL"),en.setValue(eo)):E["Next Swap Span"]>2*E["Total Threads"]?K.setValue("DISPERSE_GLOBAL"):K.setValue("DISPERSE_LOCAL"),o.copyBufferToBuffer(b,0,C,0,x),o.copyBufferToBuffer(y,0,P,0,Uint32Array.BYTES_PER_ELEMENT)}if(t.queue.submit([o.finish()]),E.executeStep){await C.mapAsync(GPUMapMode.READ,0,x);let l=C.getMappedRange(0,x);await P.mapAsync(GPUMapMode.READ,0,Uint32Array.BYTES_PER_ELEMENT);let u=P.getMappedRange(0,Uint32Array.BYTES_PER_ELEMENT),d=l.slice(0,Uint32Array.BYTES_PER_ELEMENT*E["Total Elements"]),c=u.slice(0,Uint32Array.BYTES_PER_ELEMENT),p=new Uint32Array(d);$.setValue(new Uint32Array(c)[0]),C.unmap(),P.unmap(),v=p,M()}E.executeStep=!1,requestAnimationFrame(ea)}D(),requestAnimationFrame(ea)}).then(e=>r=e);let S=()=>(0,i.Tl)({name:"Bitonic Sort",description:"A naive bitonic sort algorithm executed on the GPU, based on tgfrerer's implementation at poniesandlight.co.uk/reflect/bitonic_merge_sort/. Each invocation of the bitonic sort shader dispatches a workgroup containing elements/2 threads. The GUI's Execution Information folder contains information about the sort's current state. The visualizer displays the sort's results as colored cells sorted from brightest to darkest.",init:r,gui:!0,sources:[{name:g.substring(23),contents:"import { makeSample, SampleInit } from '../../components/SampleLayout';\nimport { createBindGroupCluster, SampleInitFactoryWebGPU } from './utils';\nimport BitonicDisplayRenderer from './bitonicDisplay';\nimport bitonicDisplay from './bitonicDisplay.frag.wgsl';\nimport { NaiveBitonicCompute } from './computeShader';\nimport fullscreenTexturedQuad from '../../shaders/fullscreenTexturedQuad.wgsl';\nimport atomicToZero from './atomicToZero.wgsl';\n\n// Type of step that will be executed in our shader\nenum StepEnum {\n  NONE,\n  FLIP_LOCAL,\n  DISPERSE_LOCAL,\n  FLIP_GLOBAL,\n  DISPERSE_GLOBAL,\n}\n\n// String access to StepEnum\ntype StepType =\n  | 'NONE'\n  | 'FLIP_LOCAL'\n  | 'DISPERSE_LOCAL'\n  | 'FLIP_GLOBAL'\n  | 'DISPERSE_GLOBAL';\n\ntype DisplayType = 'Elements' | 'Swap Highlight';\n\n// Gui settings object\ninterface SettingsInterface {\n  'Total Elements': number;\n  'Grid Width': number;\n  'Grid Height': number;\n  'Total Threads': number;\n  'Hovered Cell': number;\n  'Swapped Cell': number;\n  'Step Index': number;\n  'Total Steps': number;\n  'Prev Step': StepType;\n  'Next Step': StepType;\n  'Prev Swap Span': number;\n  'Next Swap Span': number;\n  'Total Workgroups': number;\n  'Display Mode': DisplayType;\n  'Total Swaps': number;\n  executeStep: boolean;\n  'Randomize Values': () => void;\n  'Execute Sort Step': () => void;\n  'Log Elements': () => void;\n  'Complete Sort': () => void;\n  'Sort Speed': number;\n}\n\nconst getNumSteps = (numElements: number) => {\n  const n = Math.log2(numElements);\n  return (n * (n + 1)) / 2;\n};\n\nlet init: SampleInit;\nSampleInitFactoryWebGPU(\n  async ({ pageState, device, gui, presentationFormat, context, canvas }) => {\n    const maxThreadsX = device.limits.maxComputeWorkgroupSizeX;\n\n    const totalElementLengths = [];\n    const maxElements = maxThreadsX * 32;\n    for (let i = maxElements; i >= 4; i /= 2) {\n      totalElementLengths.push(i);\n    }\n\n    const defaultGridWidth =\n      Math.sqrt(maxElements) % 2 === 0\n        ? Math.floor(Math.sqrt(maxElements))\n        : Math.floor(Math.sqrt(maxElements / 2));\n\n    const defaultGridHeight = maxElements / defaultGridWidth;\n\n    const settings: SettingsInterface = {\n      // number of cellElements. Must equal gridWidth * gridHeight and 'Total Threads' * 2\n      'Total Elements': maxElements,\n      // width of screen in cells.\n      'Grid Width': defaultGridWidth,\n      // height of screen in cells\n      'Grid Height': defaultGridHeight,\n      // number of threads to execute in a workgroup ('Total Threads', 1, 1)\n      'Total Threads': maxThreadsX,\n      // Cell in element grid mouse element is hovering over\n      'Hovered Cell': 0,\n      // element the hovered cell just swapped with,\n      'Swapped Cell': 1,\n      // Index of current step\n      'Step Index': 0,\n      // Total steps to sort current number of elements\n      'Total Steps': getNumSteps(maxElements),\n      // Previously executed step\n      'Prev Step': 'NONE',\n      // Next step to execute\n      'Next Step': 'FLIP_LOCAL',\n      // Max thread span of previous block\n      'Prev Swap Span': 0,\n      // Max thread span of next block\n      'Next Swap Span': 2,\n      // Workgroups to dispatch per frame,\n      'Total Workgroups': maxElements / (maxThreadsX * 2),\n      // The number of swap operations executed over time\n      'Total Swaps': 0,\n      // Whether we will dispatch a workload this frame\n      executeStep: false,\n      'Display Mode': 'Elements',\n      'Randomize Values': () => {\n        return;\n      },\n      'Execute Sort Step': () => {\n        return;\n      },\n      'Log Elements': () => {\n        return;\n      },\n      'Complete Sort': () => {\n        return;\n      },\n      'Sort Speed': 50,\n    };\n\n    // Initialize initial elements array\n    let elements = new Uint32Array(\n      Array.from({ length: settings['Total Elements'] }, (_, i) => i)\n    );\n\n    // Initialize elementsBuffer and elementsStagingBuffer\n    const elementsBufferSize =\n      Float32Array.BYTES_PER_ELEMENT * totalElementLengths[0];\n    // Initialize input, output, staging buffers\n    const elementsInputBuffer = device.createBuffer({\n      size: elementsBufferSize,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    const elementsOutputBuffer = device.createBuffer({\n      size: elementsBufferSize,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n    const elementsStagingBuffer = device.createBuffer({\n      size: elementsBufferSize,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n\n    // Initialize atomic swap buffer on GPU and CPU. Counts number of swaps actually performed by\n    // compute shader (when value at index x is greater than value at index y)\n    const atomicSwapsOutputBuffer = device.createBuffer({\n      size: Uint32Array.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n    const atomicSwapsStagingBuffer = device.createBuffer({\n      size: Uint32Array.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n\n    // Create uniform buffer for compute shader\n    const computeUniformsBuffer = device.createBuffer({\n      // width, height, blockHeight, algo\n      size: Float32Array.BYTES_PER_ELEMENT * 4,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n\n    const computeBGCluster = createBindGroupCluster(\n      [0, 1, 2, 3],\n      [\n        GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n        GPUShaderStage.COMPUTE,\n        GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n        GPUShaderStage.COMPUTE,\n      ],\n      ['buffer', 'buffer', 'buffer', 'buffer'],\n      [\n        { type: 'read-only-storage' },\n        { type: 'storage' },\n        { type: 'uniform' },\n        { type: 'storage' },\n      ],\n      [\n        [\n          { buffer: elementsInputBuffer },\n          { buffer: elementsOutputBuffer },\n          { buffer: computeUniformsBuffer },\n          { buffer: atomicSwapsOutputBuffer },\n        ],\n      ],\n      'BitonicSort',\n      device\n    );\n\n    let computePipeline = device.createComputePipeline({\n      layout: device.createPipelineLayout({\n        bindGroupLayouts: [computeBGCluster.bindGroupLayout],\n      }),\n      compute: {\n        module: device.createShaderModule({\n          code: NaiveBitonicCompute(settings['Total Threads']),\n        }),\n        entryPoint: 'computeMain',\n      },\n    });\n\n    // Simple pipeline that zeros out an atomic value at group 0 binding 3\n    const atomicToZeroComputePipeline = device.createComputePipeline({\n      layout: device.createPipelineLayout({\n        bindGroupLayouts: [computeBGCluster.bindGroupLayout],\n      }),\n      compute: {\n        module: device.createShaderModule({\n          code: atomicToZero,\n        }),\n        entryPoint: 'atomicToZero',\n      },\n    });\n\n    // Create bitonic debug renderer\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: [\n        {\n          view: undefined, // Assigned later\n\n          clearValue: { r: 0.1, g: 0.4, b: 0.5, a: 1.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    };\n\n    const bitonicDisplayRenderer = new BitonicDisplayRenderer(\n      device,\n      presentationFormat,\n      renderPassDescriptor,\n      computeBGCluster,\n      'BitonicDisplay'\n    );\n\n    const resetExecutionInformation = () => {\n      // Total threads are either elements / 2 or maxWorkgroupsSizeX\n      totalThreadsController.setValue(\n        Math.min(settings['Total Elements'] / 2, maxThreadsX)\n      );\n\n      // Dispatch a workgroup for every (Max threads * 2) elements\n      const workgroupsPerStep =\n        (settings['Total Elements'] - 1) / (maxThreadsX * 2);\n\n      totalWorkgroupsController.setValue(Math.ceil(workgroupsPerStep));\n\n      // Reset step Index and number of steps based on elements size\n      stepIndexController.setValue(0);\n      totalStepsController.setValue(getNumSteps(settings['Total Elements']));\n\n      // Get new width and height of screen display in cells\n      const newCellWidth =\n        Math.sqrt(settings['Total Elements']) % 2 === 0\n          ? Math.floor(Math.sqrt(settings['Total Elements']))\n          : Math.floor(Math.sqrt(settings['Total Elements'] / 2));\n      const newCellHeight = settings['Total Elements'] / newCellWidth;\n      gridWidthController.setValue(newCellWidth);\n      gridHeightController.setValue(newCellHeight);\n\n      // Set prevStep to None (restart) and next step to FLIP\n      prevStepController.setValue('NONE');\n      nextStepController.setValue('FLIP_LOCAL');\n\n      // Reset block heights\n      prevBlockHeightController.setValue(0);\n      nextBlockHeightController.setValue(2);\n\n      // Reset Total Swaps by setting atomic value to 0\n      const commandEncoder = device.createCommandEncoder();\n      const computePassEncoder = commandEncoder.beginComputePass();\n      computePassEncoder.setPipeline(atomicToZeroComputePipeline);\n      computePassEncoder.setBindGroup(0, computeBGCluster.bindGroups[0]);\n      computePassEncoder.dispatchWorkgroups(1);\n      computePassEncoder.end();\n      device.queue.submit([commandEncoder.finish()]);\n      totalSwapsController.setValue(0);\n\n      highestBlockHeight = 2;\n    };\n\n    const randomizeElementArray = () => {\n      let currentIndex = elements.length;\n      // While there are elements to shuffle\n      while (currentIndex !== 0) {\n        // Pick a remaining element\n        const randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex -= 1;\n        [elements[currentIndex], elements[randomIndex]] = [\n          elements[randomIndex],\n          elements[currentIndex],\n        ];\n      }\n    };\n\n    const resizeElementArray = () => {\n      // Recreate elements array with new length\n      elements = new Uint32Array(\n        Array.from({ length: settings['Total Elements'] }, (_, i) => i)\n      );\n\n      resetExecutionInformation();\n\n      // Create new shader invocation with workgroupSize that reflects number of threads\n      computePipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n          bindGroupLayouts: [computeBGCluster.bindGroupLayout],\n        }),\n        compute: {\n          module: device.createShaderModule({\n            code: NaiveBitonicCompute(settings['Total Elements'] / 2),\n          }),\n          entryPoint: 'computeMain',\n        },\n      });\n      // Randomize array elements\n      randomizeElementArray();\n      highestBlockHeight = 2;\n    };\n\n    randomizeElementArray();\n\n    const setSwappedCell = () => {\n      let swappedIndex: number;\n      switch (settings['Next Step']) {\n        case 'FLIP_LOCAL':\n        case 'FLIP_GLOBAL':\n          {\n            const blockHeight = settings['Next Swap Span'];\n            const p2 = Math.floor(settings['Hovered Cell'] / blockHeight) + 1;\n            const p3 = settings['Hovered Cell'] % blockHeight;\n            swappedIndex = blockHeight * p2 - p3 - 1;\n            swappedCellController.setValue(swappedIndex);\n          }\n          break;\n        case 'DISPERSE_LOCAL':\n          {\n            const blockHeight = settings['Next Swap Span'];\n            const halfHeight = blockHeight / 2;\n            swappedIndex =\n              settings['Hovered Cell'] % blockHeight < halfHeight\n                ? settings['Hovered Cell'] + halfHeight\n                : settings['Hovered Cell'] - halfHeight;\n            swappedCellController.setValue(swappedIndex);\n          }\n          break;\n        case 'NONE': {\n          swappedIndex = settings['Hovered Cell'];\n          swappedCellController.setValue(swappedIndex);\n        }\n        default:\n          {\n            swappedIndex = settings['Hovered Cell'];\n            swappedCellController.setValue(swappedIndex);\n          }\n          break;\n      }\n    };\n\n    let completeSortIntervalID: ReturnType<typeof setInterval> | null = null;\n    const endSortInterval = () => {\n      if (completeSortIntervalID !== null) {\n        clearInterval(completeSortIntervalID);\n        completeSortIntervalID = null;\n      }\n    };\n    const startSortInterval = () => {\n      const currentIntervalSpeed = settings['Sort Speed'];\n      completeSortIntervalID = setInterval(() => {\n        if (settings['Next Step'] === 'NONE') {\n          clearInterval(completeSortIntervalID);\n          completeSortIntervalID = null;\n        }\n        if (settings['Sort Speed'] !== currentIntervalSpeed) {\n          clearInterval(completeSortIntervalID);\n          completeSortIntervalID = null;\n          startSortInterval();\n        }\n        settings.executeStep = true;\n        setSwappedCell();\n      }, settings['Sort Speed']);\n    };\n\n    // At top level, information about resources used to execute the compute shader\n    // i.e elements sorted, threads/invocations per workgroup, and workgroups dispatched\n    const computeResourcesFolder = gui.addFolder('Compute Resources');\n    computeResourcesFolder\n      .add(settings, 'Total Elements', totalElementLengths)\n      .onChange(() => {\n        endSortInterval();\n        resizeElementArray();\n      });\n    const totalThreadsController = computeResourcesFolder.add(\n      settings,\n      'Total Threads'\n    );\n    const totalWorkgroupsController = computeResourcesFolder.add(\n      settings,\n      'Total Workgroups'\n    );\n    computeResourcesFolder.open();\n\n    // Folder with functions that control the execution of the sort\n    const controlFolder = gui.addFolder('Sort Controls');\n    controlFolder.add(settings, 'Sort Speed', 50, 1000).step(50);\n    controlFolder.add(settings, 'Execute Sort Step').onChange(() => {\n      endSortInterval();\n      settings.executeStep = true;\n    });\n    controlFolder.add(settings, 'Randomize Values').onChange(() => {\n      endSortInterval();\n      randomizeElementArray();\n      resetExecutionInformation();\n    });\n    controlFolder\n      .add(settings, 'Log Elements')\n      .onChange(() => console.log(elements));\n    controlFolder.add(settings, 'Complete Sort').onChange(startSortInterval);\n    controlFolder.open();\n\n    // Information about grid display\n    const gridFolder = gui.addFolder('Grid Information');\n    gridFolder.add(settings, 'Display Mode', ['Elements', 'Swap Highlight']);\n    const gridWidthController = gridFolder.add(settings, 'Grid Width');\n    const gridHeightController = gridFolder.add(settings, 'Grid Height');\n    const hoveredCellController = gridFolder\n      .add(settings, 'Hovered Cell')\n      .onChange(setSwappedCell);\n    const swappedCellController = gridFolder.add(settings, 'Swapped Cell');\n\n    // Additional Information about the execution state of the sort\n    const executionInformationFolder = gui.addFolder('Execution Information');\n    const stepIndexController = executionInformationFolder.add(\n      settings,\n      'Step Index'\n    );\n    const totalStepsController = executionInformationFolder.add(\n      settings,\n      'Total Steps'\n    );\n    const prevStepController = executionInformationFolder.add(\n      settings,\n      'Prev Step'\n    );\n    const nextStepController = executionInformationFolder.add(\n      settings,\n      'Next Step'\n    );\n    const totalSwapsController = executionInformationFolder.add(\n      settings,\n      'Total Swaps'\n    );\n    const prevBlockHeightController = executionInformationFolder.add(\n      settings,\n      'Prev Swap Span'\n    );\n    const nextBlockHeightController = executionInformationFolder.add(\n      settings,\n      'Next Swap Span'\n    );\n\n    // Adjust styles of Function List Elements within GUI\n    const liFunctionElements = document.getElementsByClassName('cr function');\n    for (let i = 0; i < liFunctionElements.length; i++) {\n      (liFunctionElements[i].children[0] as HTMLElement).style.display = 'flex';\n      (liFunctionElements[i].children[0] as HTMLElement).style.justifyContent =\n        'center';\n      (\n        liFunctionElements[i].children[0].children[1] as HTMLElement\n      ).style.position = 'absolute';\n    }\n\n    canvas.addEventListener('mousemove', (event) => {\n      const currWidth = canvas.getBoundingClientRect().width;\n      const currHeight = canvas.getBoundingClientRect().height;\n      const cellSize: [number, number] = [\n        currWidth / settings['Grid Width'],\n        currHeight / settings['Grid Height'],\n      ];\n      const xIndex = Math.floor(event.offsetX / cellSize[0]);\n      const yIndex =\n        settings['Grid Height'] - 1 - Math.floor(event.offsetY / cellSize[1]);\n      hoveredCellController.setValue(yIndex * settings['Grid Width'] + xIndex);\n      settings['Hovered Cell'] = yIndex * settings['Grid Width'] + xIndex;\n    });\n\n    // Deactivate interaction with select GUI elements\n    totalWorkgroupsController.domElement.style.pointerEvents = 'none';\n    hoveredCellController.domElement.style.pointerEvents = 'none';\n    swappedCellController.domElement.style.pointerEvents = 'none';\n    stepIndexController.domElement.style.pointerEvents = 'none';\n    totalStepsController.domElement.style.pointerEvents = 'none';\n    prevStepController.domElement.style.pointerEvents = 'none';\n    prevBlockHeightController.domElement.style.pointerEvents = 'none';\n    nextStepController.domElement.style.pointerEvents = 'none';\n    nextBlockHeightController.domElement.style.pointerEvents = 'none';\n    totalThreadsController.domElement.style.pointerEvents = 'none';\n    gridWidthController.domElement.style.pointerEvents = 'none';\n    gridHeightController.domElement.style.pointerEvents = 'none';\n    totalSwapsController.domElement.style.pointerEvents = 'none';\n\n    let highestBlockHeight = 2;\n\n    startSortInterval();\n\n    async function frame() {\n      if (!pageState.active) return;\n\n      // Write elements buffer\n      device.queue.writeBuffer(\n        elementsInputBuffer,\n        0,\n        elements.buffer,\n        elements.byteOffset,\n        elements.byteLength\n      );\n\n      const dims = new Float32Array([\n        settings['Grid Width'],\n        settings['Grid Height'],\n      ]);\n      const stepDetails = new Uint32Array([\n        StepEnum[settings['Next Step']],\n        settings['Next Swap Span'],\n      ]);\n      device.queue.writeBuffer(\n        computeUniformsBuffer,\n        0,\n        dims.buffer,\n        dims.byteOffset,\n        dims.byteLength\n      );\n\n      device.queue.writeBuffer(computeUniformsBuffer, 8, stepDetails);\n\n      renderPassDescriptor.colorAttachments[0].view = context\n        .getCurrentTexture()\n        .createView();\n\n      const commandEncoder = device.createCommandEncoder();\n      bitonicDisplayRenderer.startRun(commandEncoder, {\n        highlight: settings['Display Mode'] === 'Elements' ? 0 : 1,\n      });\n      if (\n        settings.executeStep &&\n        highestBlockHeight !== settings['Total Elements'] * 2\n      ) {\n        const computePassEncoder = commandEncoder.beginComputePass();\n        computePassEncoder.setPipeline(computePipeline);\n        computePassEncoder.setBindGroup(0, computeBGCluster.bindGroups[0]);\n        computePassEncoder.dispatchWorkgroups(settings['Total Workgroups']);\n        computePassEncoder.end();\n        stepIndexController.setValue(settings['Step Index'] + 1);\n        prevStepController.setValue(settings['Next Step']);\n        prevBlockHeightController.setValue(settings['Next Swap Span']);\n        nextBlockHeightController.setValue(settings['Next Swap Span'] / 2);\n        if (settings['Next Swap Span'] === 1) {\n          highestBlockHeight *= 2;\n          if (highestBlockHeight === settings['Total Elements'] * 2) {\n            nextStepController.setValue('NONE');\n            nextBlockHeightController.setValue(0);\n          } else if (highestBlockHeight > settings['Total Threads'] * 2) {\n            nextStepController.setValue('FLIP_GLOBAL');\n            nextBlockHeightController.setValue(highestBlockHeight);\n          } else {\n            nextStepController.setValue('FLIP_LOCAL');\n            nextBlockHeightController.setValue(highestBlockHeight);\n          }\n        } else {\n          settings['Next Swap Span'] > settings['Total Threads'] * 2\n            ? nextStepController.setValue('DISPERSE_GLOBAL')\n            : nextStepController.setValue('DISPERSE_LOCAL');\n        }\n\n        // Copy GPU accessible buffers to CPU accessible buffers\n        commandEncoder.copyBufferToBuffer(\n          elementsOutputBuffer,\n          0,\n          elementsStagingBuffer,\n          0,\n          elementsBufferSize\n        );\n\n        commandEncoder.copyBufferToBuffer(\n          atomicSwapsOutputBuffer,\n          0,\n          atomicSwapsStagingBuffer,\n          0,\n          Uint32Array.BYTES_PER_ELEMENT\n        );\n      }\n      device.queue.submit([commandEncoder.finish()]);\n\n      if (settings.executeStep) {\n        // Copy GPU element data to CPU\n        await elementsStagingBuffer.mapAsync(\n          GPUMapMode.READ,\n          0,\n          elementsBufferSize\n        );\n        const copyElementsBuffer = elementsStagingBuffer.getMappedRange(\n          0,\n          elementsBufferSize\n        );\n        // Copy atomic swaps data to CPU\n        await atomicSwapsStagingBuffer.mapAsync(\n          GPUMapMode.READ,\n          0,\n          Uint32Array.BYTES_PER_ELEMENT\n        );\n        const copySwapsBuffer = atomicSwapsStagingBuffer.getMappedRange(\n          0,\n          Uint32Array.BYTES_PER_ELEMENT\n        );\n        // Get correct range of data from CPU copy of GPU Data\n        const elementsData = copyElementsBuffer.slice(\n          0,\n          Uint32Array.BYTES_PER_ELEMENT * settings['Total Elements']\n        );\n        const swapsData = copySwapsBuffer.slice(\n          0,\n          Uint32Array.BYTES_PER_ELEMENT\n        );\n        // Extract data\n        const elementsOutput = new Uint32Array(elementsData);\n        totalSwapsController.setValue(new Uint32Array(swapsData)[0]);\n        elementsStagingBuffer.unmap();\n        atomicSwapsStagingBuffer.unmap();\n        // Elements output becomes elements input, swap accumulate\n        elements = elementsOutput;\n        setSwappedCell();\n      }\n      settings.executeStep = false;\n      requestAnimationFrame(frame);\n    }\n    requestAnimationFrame(frame);\n  }\n).then((resultInit) => (init = resultInit));\n\nconst bitonicSortExample: () => JSX.Element = () =>\n  makeSample({\n    name: 'Bitonic Sort',\n    description:\n      \"A naive bitonic sort algorithm executed on the GPU, based on tgfrerer's implementation at poniesandlight.co.uk/reflect/bitonic_merge_sort/. Each invocation of the bitonic sort shader dispatches a workgroup containing elements/2 threads. The GUI's Execution Information folder contains information about the sort's current state. The visualizer displays the sort's results as colored cells sorted from brightest to darkest.\",\n    init,\n    gui: true,\n    sources: [\n      {\n        name: __filename.substring(__dirname.length + 1),\n        contents: __SOURCE__,\n      },\n      BitonicDisplayRenderer.sourceInfo,\n      {\n        name: '../../../shaders/fullscreenTexturedQuad.vert.wgsl',\n        contents: fullscreenTexturedQuad,\n      },\n      {\n        name: './bitonicDisplay.frag.wgsl',\n        contents: bitonicDisplay,\n      },\n      {\n        name: './bitonicCompute.frag.wgsl',\n        contents: NaiveBitonicCompute(64),\n      },\n      {\n        name: './atomicToZero.wgsl',\n        contents: atomicToZero,\n      },\n    ],\n    filename: __filename,\n  });\n\nexport default bitonicSortExample;\n"},p.sourceInfo,{name:"../../../shaders/fullscreenTexturedQuad.vert.wgsl",contents:s.Z},{name:"./bitonicDisplay.frag.wgsl",contents:c},{name:"./bitonicCompute.frag.wgsl",contents:m(64)},{name:"./atomicToZero.wgsl",contents:f}],filename:g});var E=S},9147:function(e){e.exports={canvasContainer:"SampleLayout_canvasContainer__zRR_l",sourceFileNav:"SampleLayout_sourceFileNav__ml48P",sourceFileContainer:"SampleLayout_sourceFileContainer__3s84x"}},134:function(e,n){"use strict";n.Z="@group(0) @binding(0) var mySampler : sampler;\n@group(0) @binding(1) var myTexture : texture_2d<f32>;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n}\n\n@vertex\nfn vert_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n  const pos = array(\n    vec2( 1.0,  1.0),\n    vec2( 1.0, -1.0),\n    vec2(-1.0, -1.0),\n    vec2( 1.0,  1.0),\n    vec2(-1.0, -1.0),\n    vec2(-1.0,  1.0),\n  );\n\n  const uv = array(\n    vec2(1.0, 0.0),\n    vec2(1.0, 1.0),\n    vec2(0.0, 1.0),\n    vec2(1.0, 0.0),\n    vec2(0.0, 1.0),\n    vec2(0.0, 0.0),\n  );\n\n  var output : VertexOutput;\n  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\n  output.fragUV = uv[VertexIndex];\n  return output;\n}\n\n@fragment\nfn frag_main(@location(0) fragUV : vec2<f32>) -> @location(0) vec4<f32> {\n  return textureSample(myTexture, mySampler, fragUV);\n}\n"}}]);